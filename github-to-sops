#!/usr/bin/env python3
"""
Standalone (no-dependencies beyond Python) script fetches SSH keys of GitHub repository contributors and generates SOPS-compatible SSH key files.
"""

import argparse
import json
import logging
import os
import sys
import subprocess
from typing import Optional, List, Set
from urllib import request, error
import re

GITHUB_TO_SOPS_TAG = "https://github.com/tarasglek/github-to-sops"
GITHUB_API_BASE_URL = "api.github.com/repos"
GENERATED_MSG = (
    f"Generated by `{' '.join(sys.argv)}` {GITHUB_TO_SOPS_TAG}"
)

SOPS_TEMPLATE = f"""
creation_rules:
  - key_groups:
      - age:
        - Mark stuff to replace by having a line with {GITHUB_TO_SOPS_TAG} which can be within a comment or not
        - Following lines with same indent get dropped
# EOF
"""

def process_template(template, tag, output_fd):
    """
    1. Takes a template string
    2. Finds line containing the specified tag
    3. Detects whitespace on the tag line and stores that as line_prefix
    4. yields it
    5. Finds first line after the tag with a different prefix
    6. Prints all other lines to console as they are being scanned
    7. Only does it once, e.g., subsequent tag lines will end up with suffix
    8. Yields None if no tag was found
    """
    lines = template.split("\n")
    found_tag = False
    scan_prefix = None
    tag_pattern = re.compile(r"^\s*")  # Precompile the regex pattern

    for line in lines:
        if not found_tag:
            if tag in line:
                found_tag = True
                # Match only the leading whitespace of the line with the tag
                match = tag_pattern.match(line)
                scan_prefix = match.group() if match else ""
                yield scan_prefix
                continue
            output_fd.write(line + "\n")
        else:
            if scan_prefix is not None:
                # Compute the current line's prefix
                current_line_prefix = tag_pattern.match(line).group()
                # Check if the current line's prefix is different from the tag's prefix
                if current_line_prefix == scan_prefix:
                    continue
                scan_prefix = None
            output_fd.write(line + "\n")
    if not found_tag:
        yield None

def get_api_url_from_git(repo_path: str) -> Optional[str]:
    """
    Extract the GitHub API URL from the local git repository using git command.

    :param repo_path: Path to the local git repository.
    :return: GitHub API URL or None if not found.
    """
    try:
        # Get the remote URL of the 'origin' remote repository
        git_url = (
            subprocess.check_output(
                ["git", "-C", repo_path, "remote", "get-url", "origin"]
            )
            .decode()
            .strip()
        )

        # Transform the git URL to the GitHub API URL
        if git_url.startswith("https://github.com/"):
            return git_url.replace(
                "https://github.com/", GITHUB_API_BASE_URL + "/", 1
            ).rstrip(".git")
        elif git_url.startswith("git@github.com:"):
            return git_url.replace(
                "git@github.com:", GITHUB_API_BASE_URL + "/", 1
            ).rstrip(".git")
    except Exception as e:
        print(f"Unexpected error: {e}", file=sys.stderr)
    return None


def get_api_url(repo_url: Optional[str], local_repo: Optional[str]) -> str:
    """
    Determine the GitHub API URL from either a repository URL or a local repository path.

    :param repo_url: GitHub repository URL.
    :param local_repo: Path to local Git repository.
    :return: GitHub API URL.
    :raises ValueError: If neither a repository URL nor a local repository path is provided.
    """
    api_url = None
    if repo_url:
        api_url = repo_url.replace("github.com", GITHUB_API_BASE_URL, 1)
    elif local_repo:
        api_url = get_api_url_from_git(local_repo)
    if api_url:
        if not api_url.startswith("https://"):
            api_url = f"https://{api_url}"
        return api_url
    else:
        raise ValueError(
            "Unable to determine the repository URL from the local Git repository."
        )


def github_request(request_url: str):
    """
    Make a request to the GitHub API.
    This injects the GitHub API token environment variable into the request if present.

    :param request_url: URL to make the request to.
    :return: Response from the GitHub API.
    """
    req = request.Request(request_url)
    github_token = os.getenv("GITHUB_TOKEN")
    if github_token:
        auth_header = f"token {github_token}"
        req.add_header("Authorization", auth_header)
    return request.urlopen(req)


def fetch_contributors(api_url: str) -> List[str]:
    """
    Fetch the list of contributors for a GitHub repository.

    :param api_url: GitHub API URL for the repository.
    :return: List of contributor usernames.
    """
    try:
        with github_request(f"{api_url}/contributors") as response:
            contributors = json.load(response)
            return [contributor["login"] for contributor in contributors]
    except error.HTTPError as e:
        print(f"HTTP Error: {e.code} {e.reason}", file=sys.stderr)
        print(
            "For private repositories and to avoid throttling you must set the GITHUB_TOKEN\n. Alternatively consider passing users explicitly via --github-users to avoid auth hassles.",
            file=sys.stderr,
        )
        return []


def convert_key_to_age(key: str) -> Optional[str]:
    """
    Convert an SSH key to an age key using ssh-to-age.

    :param key: The SSH key to convert.
    :return: The age key or None if conversion fails.
    """
    try:
        result = subprocess.run(
            ["ssh-to-age"], input=key, stdout=subprocess.PIPE, text=True, check=True
        )
        return result.stdout.strip()
    except Exception as e:
        print(f"Error running ssh-to-age: {e}", file=sys.stderr)
    return None


def fetch_github_ssh_keys(contributors: List[str]):
    """
    Fetch and output the specified types of SSH keys for a list of GitHub users.
    Optionally convert the keys to age keys using ssh-to-age. Output key types
    that the user doesn't have if the key_types parameter is set.

    :param contributors: List of GitHub usernames.
    """
    keys_by_user_and_type = {}
    for username in contributors:
        user_keys = keys_by_user_and_type.get(username, {})
        try:
            with github_request(f"https://github.com/{username}.keys") as response:
                lines = response.read().decode().strip().splitlines()
                for line in lines:
                    key_type, key = line.split(" ")
                    user_keys[key_type] = key
                    keys_by_user_and_type[username] = user_keys
        except error.HTTPError as e:
            print(
                f"HTTP Error: {e.code} {e.reason} for user {username}", file=sys.stderr
            )
            continue
    return keys_by_user_and_type


def iterate_keys(
    keys: dict,
    accepted_key_types: Optional[Set[str]] = None,
):
    """
    Print keys in useful formats

    :param key_types: The types of SSH keys to fetch (e.g., ['ssh-ed25519', 'ssh-rsa']) or None for all keys.
    :param convert_to_age: Whether to convert the keys to age keys.
    """
    for username, user_keys in keys.items():
        if accepted_key_types is not None:
            accepted_keys = set(user_keys.keys()).intersection(accepted_key_types)
        else:
            accepted_keys = user_keys.keys()
        if not accepted_keys:
            print(
                f"User {username} does not have any of the accepted key types: {','.join(list(accepted_key_types))}.",
                file=sys.stderr,
            )
        for key_type in accepted_keys:
            key = user_keys[key_type]
            yield {"username": username, "key_type": key_type, "key": key}


def ssh_keyscan(hosts: List[str], parsed_keys={}):
    def ssh_keyscan(host: str) -> str:
        try:
            # Run the ssh-keyscan command
            result = subprocess.run(
                ["ssh-keyscan", host],
                check=True,
                stdout=subprocess.PIPE,
                text=True
            )
            # Return the stdout if the command was successful
            return result.stdout
        except subprocess.CalledProcessError as e:
            raise Exception(f"ssh-keyscan failed with exit code {e.returncode}: {e.stderr}")

    def parse_known_hosts_content(known_hosts, parsed_keys={}):
        for line in known_hosts.splitlines():
            # Skip comments and empty lines
            if line.startswith("#") or line.strip() == "":
                continue

            # Skip invalid lines
            parts = line.strip().split()
            if len(parts) < 3:
                continue  # Skip invalid lines

            host, key_type, key = parts[0], parts[1], parts[2]
            # Note keys might be hashed
            if host not in parsed_keys:
                parsed_keys[host] = {}
            parsed_keys[host][key_type] = key

    for host in hosts:
        known_hosts_log = ssh_keyscan(host)
        parse_known_hosts_content(known_hosts_log, parsed_keys)

    return parsed_keys

def is_tool_available(name):
    """Check if a tool is available on the system."""
    try:
        subprocess.run(
            [name, "--version"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            check=True,
        )
        return True
    except (OSError, subprocess.CalledProcessError):
        return False


def comma_separated_list(string) -> Set[str]:
    return set(string.split(","))

def print_keys(template, keys, accepted_key_types, output_format, output_fd):
    for line_prefix in process_template(template, GITHUB_TO_SOPS_TAG, output_fd):
        if line_prefix is None:
            line_prefix = ""
        print(f"{line_prefix}# {GENERATED_MSG}", file=output_fd)
        for entry in iterate_keys(keys=keys, accepted_key_types=accepted_key_types):
            username = entry["username"]
            key_type = entry["key_type"]
            key = entry["key"]
            if output_format in ["ssh-to-age", "sops"]:
                key = convert_key_to_age(f"{key_type} {key}")
                if not key:
                    print(
                        f"Skipped converting {key_type} key for user {username} to age key with ssh-to-age",
                        file=sys.stderr,
                    )
                    continue
                if output_format == "sops":
                    print(f"{line_prefix}- {key} # {username}", file=output_fd)
                else:
                    print(f"{key}", file=output_fd)
            else:
                print(f"{key_type} {key} {username}", file=output_fd)

def main():
    parser = argparse.ArgumentParser(
        description="Fetch SSH keys of GitHub repository contributors or specified github users and output that info into a useful format like sops or ssh authorized_keys",
        epilog=f"""Example invocations:
`{sys.argv[0]} --github-url https://github.com/tarasglek/chatcraft.org --key-types ssh-ed25519 --format sops`
`{sys.argv[0]} --github-url https://github.com/tarasglek/chatcraft.org --format authorized_keys`
`{sys.argv[0]} --local-github-checkout . --format sops --ssh-hosts 192.168.1.1,192.168.1.2 --key-types ssh-ed25519`
""",
    )
    group = parser.add_mutually_exclusive_group()
    group.add_argument("--github-url", help="GitHub repository URL.")
    group.add_argument("--local-github-checkout", help="Path to local Git repository.")
    parser.add_argument(
        "--ssh-hosts",
        type=comma_separated_list,
        help="Comma-separated list of ssh servers to fetch public keys from."
    )
    parser.add_argument(
        "--github-users",
        type=comma_separated_list,
        help="Comma-separated list of GitHub usernames to fetch keys for.",
    )
    parser.add_argument(
        "--key-types",
        type=comma_separated_list,
        default=None,
        help="Comma-separated types of SSH keys to fetch (e.g., ssh-ed25519,ssh-rsa). Pass no value for all types.",
    )
    # Supported conversions with validation
    supported_conversions = ["authorized_keys", "ssh-to-age", "sops"]
    parser.add_argument(
        "--format",
        default=supported_conversions[0],
        type=str,
        choices=supported_conversions,
        help=f"Output/convert keys using the specified format. Supported formats: "
        f"{', '.join(supported_conversions)}. For example, use '--format "
        f"ssh-to-age' to convert SSH keys to age keys.",
    )
    parser.add_argument(
        "--inplace-edit",
        help="Edit SOPS file in-place. This sets --format to sops",
    )
    parser.add_argument(
        "-v",
        "--verbose",
        help="Turn on debug logging to see HTTP requests and other internal Python stuff.",
        action="store_true",
    )
    args = parser.parse_args()

    # Configure logging based on the verbose flag
    if args.verbose:
        # todo turn on internal http logging in python
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)

    github_users = []

    if args.github_users:
        github_users = args.github_users
    elif args.github_url or args.local_github_checkout:
        github_users = fetch_contributors(
            get_api_url(args.github_url, args.local_github_checkout)
        )

    keys = {}
    if github_users:
        keys = fetch_github_ssh_keys(github_users)
    if args.ssh_hosts:
        keys = ssh_keyscan(args.ssh_hosts, keys)
    if not keys:
        print(
            "No users found or error fetching github users and no --ssh-hosts provided",
            file=sys.stderr,
        )
        sys.exit(1)

    input_template = ""
    output_fd=sys.stdout
    if args.format == "sops":
        input_template = SOPS_TEMPLATE
    if args.inplace_edit:
        args.format = "sops"
        input_template = open(args.inplace_edit, "r").read()
        output_fd = open(args.inplace_edit + ".tmp", "w")

    print_keys(
        template=input_template.strip(),
        keys=keys,
        accepted_key_types=args.key_types,
        output_format=args.format,
        output_fd=output_fd,
    )
    if args.inplace_edit:
        output_fd.close()
        os.rename(args.inplace_edit + ".tmp", args.inplace_edit)

if __name__ == "__main__":
    main()
